import matplotlib.pyplot as plt
import numpy as np

def plot_history(history):
    plt.figure(figsize=(15, 5))

    # Loss Plot
    plt.subplot(1, 3, 1)
    plt.plot(history['loss'], label='Train Loss', color='blue')
    plt.plot(history['val_loss'], label='Validation Loss', color='orange')
    plt.title('Loss Over Epochs')
    plt.xlabel('Epochs')
    plt.ylabel('Loss')
    plt.legend()
    
    # PSNR Plot
    if 'psnr' in history:
        plt.subplot(1, 3, 2)
        plt.plot(history['psnr'], label='Train PSNR', color='green')
        plt.plot(history['val_psnr'], label='Validation PSNR', color='red')
        plt.title('PSNR Over Epochs')
        plt.xlabel('Epochs')
        plt.ylabel('PSNR (dB)')
        plt.legend()
    
    # SSIM Plot
    if 'ssim' in history:
        plt.subplot(1, 3, 3)
        plt.plot(history['ssim'], label='Train SSIM', color='purple')
        plt.plot(history['val_ssim'], label='Validation SSIM', color='pink')
        plt.title('SSIM Over Epochs')
        plt.xlabel('Epochs')
        plt.ylabel('SSIM')
        plt.legend()
    
    plt.tight_layout()
    plt.show()

def plot_to_compare(low_res, high_res, model_output, colormap = 'gray'):
    """
    Plots a comparison between low-resolution, model-generated high-resolution, 
    and original high-resolution images.

    Args:
        low_res (numpy.ndarray): The low-resolution image (e.g., downsampled image).
        high_res (numpy.ndarray): The original high-resolution image.
        model_output (numpy.ndarray): The high-resolution image generated by the model.

    The function creates a 1x3 subplot:
        - The first plot displays the low-resolution image.
        - The second plot displays the high-resolution image output by the model.
        - The third plot displays the original high-resolution image.
    """
    plt.figure(figsize=(20, 5))

    # Low-Resolution Image
    plt.subplot(1, 3, 1)
    plt.title(f"Low-Resolution ({low_res.shape[0]}x{low_res.shape[1]})")
    plt.imshow(low_res, cmap=colormap)
    plt.colorbar()

    # Model High-Resolution Image
    plt.subplot(1, 3, 2)
    plt.title(f"Model High-Resolution ({model_output.shape[0]}x{model_output.shape[1]})")
    plt.imshow(model_output, cmap=colormap)
    plt.colorbar()

    # Original High-Resolution Image
    plt.subplot(1, 3, 3)
    plt.title(f"Original High-Resolution ({high_res.shape[0]}x{high_res.shape[1]})")
    plt.imshow(high_res, cmap=colormap) #cmap='viridis', vmin=0, vmax=1
    plt.colorbar()

    plt.tight_layout()  # Ensures the subplots don't overlap
    plt.show()

def plot_per_pixel_metrics(mse, mae, psnr, ssim):
    """
    Plots per-pixel MSE, MAE, PSNR, and SSIM as heatmaps.
    
    Parameters:
    - mse: Per-pixel Mean Squared Error (H, W, C)
    - mae: Per-pixel Mean Absolute Error (H, W, C)
    - psnr: Per-pixel Peak Signal-to-Noise Ratio (H, W, C)
    - ssim: Per-pixel Structural Similarity Index (H, W, C)
    """
    # Convert multi-channel (RGB) to grayscale by averaging over channels
    mse_gray = np.mean(mse, axis=-1)
    mae_gray = np.mean(mae, axis=-1)
    psnr_gray = np.mean(psnr, axis=-1)
    ssim_gray = np.mean(ssim, axis=-1)

    # Plot the heatmaps
    fig, axes = plt.subplots(2, 2, figsize=(20, 10))

    im1 = axes[0, 0].imshow(mse_gray, cmap='inferno')
    axes[0, 0].set_title("Per-Pixel MSE")
    plt.colorbar(im1, ax=axes[0, 0])

    im2 = axes[0, 1].imshow(mae_gray, cmap='magma')
    axes[0, 1].set_title("Per-Pixel MAE")
    plt.colorbar(im2, ax=axes[0, 1])

    im3 = axes[1, 0].imshow(psnr_gray, cmap='viridis')
    axes[1, 0].set_title("Per-Pixel PSNR")
    plt.colorbar(im3, ax=axes[1, 0])

    im4 = axes[1, 1].imshow(ssim_gray, cmap='plasma')
    axes[1, 1].set_title("Per-Pixel SSIM")
    plt.colorbar(im4, ax=axes[1, 1])

    # Adjust layout
    plt.tight_layout()
    plt.show()


def plot_degrees_mae(degrees_mae):
    """
    Plots a heatmap of the per-pixel Mean Absolute Error (MAE) in degrees.

    This function takes a 2D or 3D array representing MAE values and visualizes 
    them using a heatmap. If the input is a multi-channel (RGB) image, it is 
    first converted to grayscale by averaging across channels.

    Parameters:
    degrees_mae (array-like): A 2D array (grayscale) or 3D array (RGB) 
                              containing per-pixel MAE values.

    Returns:
    None: Displays the heatmap plot.
    """

    # Convert multi-channel (RGB) to grayscale by averaging over channels
    mae_gray = np.mean(degrees_mae, axis=-1)

    # Create the heatmap plot
    fig, ax = plt.subplots(figsize=(10, 5))  # Adjusted figure size

    im = ax.imshow(mae_gray, cmap='magma')
    ax.set_title("Per-Pixel MAE in Degrees")

    # Add a colorbar
    plt.colorbar(im, ax=ax)

    # Show the plot
    plt.tight_layout()
    plt.show()

def plot_mask_grid(mask):
    """
    Plots a binary or continuous mask grid.

    This function takes a 2D or 3D array representing a land-sea or other mask 
    and visualizes it using a heatmap. If the input is a multi-channel (RGB) mask, 
    it is first converted to grayscale by averaging across channels.

    Parameters:
    mask (array-like): A 2D array (grayscale) or 3D array (RGB) 
                       containing per-pixel mask values.

    Returns:
    None: Displays the mask grid plot.
    """

    # Create the plot
    fig, ax = plt.subplots(figsize=(10, 5))  # Adjusted figure size

    # Use a colormap suitable for masks (gray for binary, viridis for continuous)
    cmap_choice = "gray" if np.array_equal(mask, mask.astype(bool)) else "viridis"

    im = ax.imshow(mask, cmap=cmap_choice)
    ax.set_title("Mask Grid")

    # Add a colorbar (only if values are not strictly 0/1)
    if not np.array_equal(mask, mask.astype(bool)):
        plt.colorbar(im, ax=ax)

    # Show the plot
    plt.tight_layout()
    plt.show()